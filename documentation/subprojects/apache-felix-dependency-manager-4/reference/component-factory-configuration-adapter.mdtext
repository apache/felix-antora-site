## @FactoryConfigurationAdapterService

Annotates a class that acts as a Factory Configuration Adapter Service. 
For each new Config Admin factory configuration matching the specified 
factoryPid, an instance of this service will be created. The adapter will be 
registered with the specified interface, and with the specified adapter 
service properties. Depending on the propagate parameter, every public 
factory configuration properties (which don't start with ".") will be 
propagated along with the adapter service properties.

Like in @ConfigurationDependency, you can optionally specify the meta types of 
your configurations for Web Console GUI customization (configuration 
heading/descriptions/default values/etc ...). 

### Annotation attributes:

----
**`provides`**    
*Required*: False    
*Default*: all directly implemented interfaces.
The interface(s) to use when registering adapters. By default, directly implemented interfaces will be registered in the OSGi registry. 

----
**`properties`**    
*Required*: False    
*Default*: --

Adapter Service properties. Notice that public factory configuration is also 
registered in service properties, (only if propagate is true). 
Public factory configuration properties are those which don't starts with a 
dot (".").

----
**`factoryPid`**    
*Required*: False    
*Default*: The class name, including the package.

Returns the factory pid whose configurations will instantiate the 
annotated service class. 
(By default, the pid is the service class name). 

----
**`updated`**    
*Required*: False    
*Default*: "updated"

The Update method to invoke (defaulting to "updated"), when a factory 
configuration is created or updated 

----
**`propagate`**    
*Required*: False    
*Default*: false

Returns true if the configuration properties must be published 
along with the service. Any additional service properties specified directly 
are merged with these. 

----
**`heading`**    
*Required*: False    
*Default*: --

The label used to display the tab name (or section) where the properties are 
displayed. Example: "Printer Service". 

----
**`description`**    
*Required*: False    
*Default*: --

A human readable description of the PID this annotation is associated with. 
Example: "Configuration for the PrinterService bundle". 

----
**`factoryMethod`**    
*Required*: False    
*Default*: --

Sets the static method used to create the adapter instance.

----
**`metadata`**    
*Required*: False    
*Default*: --
An array of "PropertyMetaData annotations, specifying property types used to 
expose properties in web console

### PropertyMetaData anotation attributes: 

----
**`description`**    
*Required*: True    
*Default*: --
Returns the property description. The description may be localized and must 
describe the semantics of this type and any constraints. 
Example: "Select the log level for the Printer Service".

----
**`type`**    
*Required*: False    
*Default*: String

Return the property primitive type (java.lang.String.class by default). 
If must be either one of the following types:

- String.class
- Long.class
- Integer.class
- Character.class
- Byte.class
- Double.class
- Float.class
- Boolean.class

----
**`defaults`**    
*Required*: False    
*Default*: --

Return a default for this property. The object must be of the appropriate 
type as defined by the cardinality and getType(). The return type is a list of 
String objects that can be converted to the appropriate type. 
The cardinality of the return array must follow the absolute cardinality of
this type. E.g. if the cardinality = 0, the array must contain 1 element. If 
the cardinality is 1, it must contain 0 or 1 elements. If it is -5, it must 
contain from 0 to max 5 elements. Note that the special case of a 0 
cardinality, meaning a single value, does not allow arrays or vectors of 0 
elements. 

----
**`cardinality`**    
*Required*: False    
*Default*: --

Returns the cardinality of this property (0 by default). The OSGi environment
handles multi valued properties in arrays or in Vector objects. 
The return value is defined as follows:

- x = Integer.MIN_VALUE:  no limit, but use Vector
- x < 0: -x = max occurrences, store in Vector
- x > 0: x = max occurrences, store in array []({{ refs..path }})
- x = Integer.MAX_VALUE: no limit, but use array []({{ refs..path }})
- x = 0: 1 occurrence required

----
**`required`**    
*Required*: False    
*Default*: true

Tells if this property is required or not. 

----
**`optionLabels`**    
*Required*: False    
*Default*: --

Return a list of valid option labels for this property. The purpose of this 
method is to allow menus with localized labels. It is associated with the 
*optionValues* attribute. The labels returned here are ordered in the same 
way as the *optionValues* attribute values. 

----
**`optionValues`**    
*Required*: False    
*Default*: --

Return a list of option values that this property can take. This list must be 
in the same sequence as the *optionLabels* attribute. 

### Usage Examples

Here, a "Dictionary" service instance is instantiated for each existing 
factory configuration instances matching the "DictionaryServiceFactory" 
factory pid:

    :::java
    @FactoryConfigurationAdapterService(factoryPid="DictionaryServiceFactory", updated="updated")
    public class DictionaryImpl implements DictionaryService
    {
        /**
          * The key of our config admin dictionary language.
          */
        final static String LANG = "lang";
             
        /**
          * The key of our config admin dictionary values.
          */
        final static String WORDS = "words";
             
        /**
          * We store all configured words in a thread-safe data structure, because ConfigAdmin
          * may invoke our updated method at any time.
          */
        private CopyOnWriteArrayList<String> m_words = new CopyOnWriteArrayList<String>();
             
        /**
          * Our Dictionary language.
          */
        private String m_lang;
         
        protected void updated(Dictionary<String, ?> config) {
            m_lang = (String) config.get(LANG);
            m_words.clear();
            String[] words = (String[]) config.get(WORDS);
            for (String word : words) {
                m_words.add(word);
            }
         }   
             // ...
    }

Here, this is the same example as above, but using meta types:

    :::java
    @FactoryConfigurationAdapterService(
          factoryPid="DictionaryServiceFactory", 
          propagate=true, 
          updated="updated",
          heading="Dictionary Services",
          description="Declare here some Dictionary instances, allowing to instantiates some DictionaryService services for a given dictionary language",
          metadata={
              @PropertyMetaData(
                     heading="Dictionary Language",
                     description="Declare here the language supported by this dictionary. " +
                         "This property will be propagated with the Dictionary Service properties.",
                     defaults={"en"},
                     id=DictionaryImpl.LANG,
                     cardinality=0),
              @PropertyMetaData(
                     heading="Dictionary words",
                     description="Declare here the list of words supported by this dictionary. This properties starts with a Dot and won't be propagated with Dictionary OSGi service properties.",
                     defaults={"hello", "world"},
                     id=DictionaryImpl.WORDS,
                     cardinality=Integer.MAX_VALUE)
          }
      )  
      public class DictionaryImpl implements DictionaryService
      {
         /**
           * The key of our config admin dictionary language.
           */
         final static String LANG = "lang";
             
         /**
           * The key of our config admin dictionary values.
           */
         final static String WORDS = "words";
             
         /**
           * We store all configured words in a thread-safe data structure, because ConfigAdmin
           * may invoke our updated method at any time.
           */
         private CopyOnWriteArrayList<String> m_words = new CopyOnWriteArrayList<String>();
             
         /**
           * Our Dictionary language.
           */
         private String m_lang;
         
         protected void updated(Dictionary<String, ?> config) {
             m_lang = (String) config.get(LANG);
             m_words.clear();
             String[] words = (String[]) config.get(WORDS);
             for (String word : words) {
                 m_words.add(word);
             }
         }
             
         // ...
    }
