Title: Apache Felix Dependency Manager - Components

Components are declared by the dependency manager and can be implemented by POJOs that contain no references to the OSGi framework whatsoever. Components are the main building blocks of your OSGi application. They have a life cycle, can register themselves as services and have zero or more dependencies.

## Life cycle

The dependency manager, as part of a bundle, shares the generic bundle life cycle explained in the OSGi specification. The life cycle of the dependency manager itself, and the components it manages, can be located inside the *active* state of the hosting bundle.

Each component you define gets its own life cycle, which is explained in the state diagram below.

{gliffy:name=state-diagram|align=center|size=L|version=2}

A component is associated with an instance. This instance can either be specified directly, or you can specify its class. If you do the latter, the actual instance will be created lazily. 

Changes in the state of the component will trigger the following life cycle methods:
* `init`, 
* `start`, 
* `stop` and 
* `destroy`.

The dependency manager will look for methods with these names and one of the following signatures in this order:
* (Component),
* ().

If you don't specify anything, the methods with these names will be invoked on the instance. By using `setCallbacks()` you can however change this behavior: You can change the names of the methods to look for. Any methods that are set to ` null ` will not be invoked at all. Another thing you can do is to specify a different instance to invoke these methods on. If you do that, you will usually want to use the first signature, which gives you a reference to the ` Component ` whose life cycle method was invoked.

## Interfaces and properties

Components in the context of the dependency manager can be published as OSGi services under one or more interface names, plus optionally a set of properties. This is no different than a normal OSGi service. It's important to mention that you don't have to register a service. If you don't, you basically created a component that can do work and have dependencies and a managed life cycle.

## Composition

When implementing more complex components, you often find yourself using more than one instance. However, several of these instances might want to have dependencies injected. In such cases you need to tell the dependency manager which instances to consider. This has to be a fixed set of instances however.

## Factories

Out of the box, there already is support for lazy instantiation, meaning that the dependency manager can create component instances for you when their required dependencies are resolved. However, sometimes creating a single instance using a default constructor is not enough. In those cases, you can tell the dependency manager to delegate the creation process to a factory.

# Annotations

This page describes the different types of Dependency Manager components:

* *Component*: Components are the main building blocks for OSGi applications. They can publish themselves as a service, and/or they can have dependencies. These dependencies will influence their life cycle as component will only be activated when all required dependencies are available.
* *Aspect Service*: A service that provides a non-functional aspect on top of an existing service. In aspect oriented programming, an aspect, or interceptor can sit between a client and another target service used by the client. An Aspect Service first tracks a target service and is created once the target service is detected. Then the Aspect Service is provided, but with a higher  ranking, and the client is transparently updated with the aspect. Aspects can be chained and may apply to the same target service (and in this case, the ranking of the Aspect service is used to chain aspects in  the proper order).
* *Adapter Service*: A Service that adapts another existing service into a new one. Like with aspects, sometimes you want to create adapters for certain services, which add certain behavior that results in the publication of (in this case) a different service. Adapters can dynamically be added and removed and allow you to keep your basic services implementations clean and simple, adding extra features on top of them in a modular way.
* *Bundle Adapter Service*: creates an OSGi service a service on top of a given bundle.
* *Resource Adapter Service*: creates an OSGi service on top of a specific Resource.
* *Factory Configuration Adapter Service*: creates an OSGi service from ConfigAdmin, using a factoryPid, and a ManagedServiceFactory.

## @Component

This annotation annotates an implementation class that optionally publishes 
an OSGi service, and optionally has some dependencies, with a managed 
lifecycle. 

### Annotation attributes

----
**`provides`**    
*Required*: No    
*Default*: all implemented interfaces, if any.   

By default, the component is registered into the OSGi registry under all 
directly implemented interfaces. If no interfaces are implemented, then the 
component is not registered, but it still has a managed lifecycle, and may 
have some dependencies. If you need to  explicitly define the list of 
interfaces (or classes) under which the  component must be registered in the 
OSGi registry, then use the *provides* attribute. You can also set this 
property to an empty array of classes  if you don't want at all your component 
to be exposed in the OSGi  registry (even if it implements some interfaces).

----
**`properties`**    
*Required*: No    
*Default*: --  

the *properties" attribute enumerates the list of properties that are part of 
the Service exposed by the component in the OSGi Registry. 
Each property is defined using the @Property annotation, which represents a  
key/value pair. When a value is actually an array of strings, 
then the *values* attribute of the @Property annotation can be used. 
This attribute  is not the only way to specify OSGi Service properties 
(see Setting Service properties in the lifecycle section).

----
**`factoryMethod`**    
*Required*: No    
*Default*: --  

This attribute refers to a static method name from the annotated class which 
can be used to instantiate the component instance. Normally, DependencyManager 
instantiates the component using its class name, and with the default 
constructor of the class, but there are some cases where it is required to 
take control of  how the component is created. For instance, this method may 
be used to create the component as a dynamic proxy ...

----
**`factorySet`**    
*Required*: No    
*Default*: --  
 
This attribute is the identifier for a component factory. By default, a 
component is automatically instantiated as a singleton when the bundle is 
started, and when all required dependencies are satisfied. But when a 
component must be created, configured, or disposed dynamically, and when 
multiple instances of the same component are needed, a factorySet should  be 
used. When you use this attribute, a java.util.Set<Dictionary>  object is 
registered into the OSGi regitry, with a specific *dm.factory.name* service 
property matching the ID you specify in the attribute. 

This Set<Dictionary> will act as a Factory API, and another component may 
define a dependency on this Set and add some configuration dictionaries in it, 
in order to fire some component instantiation/activation. There is one 
component instantiated per added dictionary, which is passed to component 
instances via a configurable callback method (using the *factoryConfigure* 
attribute). All public properties will be propagated  along with eventual 
published service. A public property is a property  which does not start with 
a dot ("."). Properties starting with a dot are considered private to the 
component, and won't be propagated to published service. This model is 
actually similar to the Declarative Service "Component Factories" concept, 
except that you don't have a dependency on a specific API, but rather on a 
basic jdk class  (java.util.Set<Dictionary>). 

Notice that, unlike in Declarative Service, the component factory is provided once the component 
bundle is started, even if required dependencies are not satisfied. This is 
useful when the component want  to dynamically configure its dependency 
filters. So, to summarize:

- Each time a new Dictionary is added into the Set, then a new instance of the annotated component will be instantiated, and this dictionary is passed to the component callback specified with the factoryConfigure attribute.
- Each time an existing Dictionary is re-added into the Set, then the corresponding component instance is updated, and the updated dictionary is also passed to the callback specified in the factoryConfigure attribute.
- Each time an existing Dictionary is removed from the Set, then the  corresponding component instance will be stopped and destroyed.

----
**`factoryConfigure`**    
*Required*: No    
*Default*: --  

This attributes sets the *configure* method name to be called with the factory 
configuration. This attribute only makes sense if the factorySet() attribute 
is used. If specified, then this attribute references a component callback 
method, which is called for providing the configuration supplied by the 
factory that instantiated this component. The current Service properties will 
be also updated with all public properties (which don't start with a dot).

Usage example:

    :::java
    /**
      * This component will be activated once the bundle is started and when all required dependencies
      * are available.
      */
    @Component
    class X implements Z {
        @ConfigurationDependency(pid="MyPid")
        void configure(Dictionary conf) {
             // Configure or reconfigure our service.
        }
    
        @Start
        void start() {
            // Our component is starting and is about to be registered in the OSGi registry as a Z service.
        }
    
        public void doService() {
            // ...
        }
    }
    

Example using a factorySet, where the X component is instantiated/updated/disposed by another Y component:

    :::java
     @Component(factorySet="MyComponentFactory", factoryConfigure="configure")
     class X implements Z {
         void configure(Dictionary conf) {
             // Configure or reconfigure our component. The conf is provided by the factory,
             // and all public properties (which don't start with a dot) are propagated with the
             // Service properties eventually specified in the properties annotation attribute.
         }
    
         @ServiceDependency
         void bindOtherService(OtherService other) {
             // store this require dependency
         }
    
         @Start
         void start() {
             // Our component is starting and is about to be registered in the OSGi registry as a Z service.
         }
    
         public void doService() {
             // ... part of Z interface
         }
     }
    
    /**
      * This class will instantiate some X component instances
      */
    @Component
    class Y {
         @ServiceDependency(filter="(dm.factory.name=MyComponentFactory)")
         Set<Dictionary> _XFactory; // This Set acts as a Factory API for creating X component instances.
    
         @Start
         void start() {
             // Instantiate a X component instance
             Dictionary x1 = new Hashtable() {{ put("foo", "bar1"); }};
             _XFactory.add(x1);
    
             // Instantiate another X component instance
             Dictionary x2 = new Hashtable() {{ put("foo", "bar2"); }};
             _XFactory.add(x2);
    
             // Update the first X component instance
             x1.put("foo", "bar1_modified");
             _XFactory.add(x1);
    
             // Destroy all components (Notice that invoking _XFactory.clear() also destroys every X instances)
             _XFactory.remove(x1);
             _XFactory.remove(x2);
         }
    }

