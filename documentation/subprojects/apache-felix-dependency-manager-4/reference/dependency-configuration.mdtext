##### Configuration

A configuration dependency is always required, and allows you to depend on the availability of a valid configuration for your component. Optional configuration dependencies are not supported because in that case you can just as well register as a ` ManagedService ` yourself.

## @ConfigurationDependency

A configuration dependency is always required, and allows you to depend on the availability of a valid configuration for your component. This dependency requires the OSGi Configuration Admin Service.

Annotation attributes:

* *pid*: Returns the pid for a given service (by default, the pid is the service class name).
* *pidClass*: Will the the name of the specified class as the the pid for a given service (by default, the pid is the service class name).
* *propagate*: Returns true if the configuration properties must be published along with the service. Any additional service properties specified directly are merged with these.
* *heading*: The label used to display the tab name (or section) where the properties are displayed. Example: "Printer Service".
* *description*: A human readable description of the PID this annotation is associated with. Example: "Configuration for the PrinterService bundle".
* *metadata*: an array of PropertyMetadaData\[\]({{ refs..path }}) annotation describing property types (see the FactoryConfigurationAdapterService section in the "Writing Components" section.

Usage Examples

In the following example, the "Printer" component depends on a configuration whose PID name is "org.apache.felix.sample.Printer". This service will initialize its ip/port number from the provided configuration:

    :::java
    package org.apache.felix.sample;
    
    @Component
    public class Printer {
        @ConfigurationDependency
        void updated(Dictionary config) {
            // load printer ip/port from the provided dictionary.
        }
    }

This other example shows how to specify a configuration dependency, as well as meta data used to customize the 
WebConsole GUI. Using these meta data, you can specify for example the default value for your 
configurations data, some descriptions, the cardinality of configuration values, etc ...
(we use here standard bnd metatype annotations, [see bnd metatype documentation here](http://www.aqute.biz/Bnd/MetaType).

 First, we define the configuration metadata, using standard bndtools metatatype annotations:

     :::java
     package sample;
     import aQute.bnd.annotation.metatype.Meta.AD;
     import aQute.bnd.annotation.metatype.Meta.OCD;

     @OCD(description = "Declare here the Printer Configuration.")
     public interface PrinterConfiguration {
         @AD(description = "Enter the printer ip address")
         String ipAddress();

         @AD(description = "Enter the printer address port number.")
         int portNumber();
     }
     
 Next, we define our Printer service which instantiates the PrinterConfiguration using the *Configurable" bndlib helper:

     package sample;
     import aQute.bnd.annotation.metatype.*;

     @Component
     public class Printer {
         @ConfigurationDependency(pidClass = PrinterConfiguration.class) // Will use pid "sample.PrinterConfiguration"
         void updated(Dictionary props) {
             // load configuration from the provided dictionary, or throw an exception of any configuration error.
             PrinterConfig cnf = Configurable.createConfigurable(PrinterConfig.class, props);
             String ip = cnf.ipAddress();
             int port = cnf.portNumber();
             ...
         }
     }
