##### Configuration

A configuration dependency is always required, and allows you to depend on the availability of a valid configuration for your component. Optional configuration dependencies are not supported because in that case you can just as well register as a ` ManagedService ` yourself.

## @ConfigurationDependency

A configuration dependency is always required, and allows you to depend on the availability of a valid configuration for your component. This dependency requires the OSGi Configuration Admin Service.

Annotation attributes:

* *pid*: Returns the pid for a given service (by default, the pid is the service class name).
* *pidClass*: Will the the name of the specified class as the the pid for a given service (by default, the pid is the service class name).
* *propagate*: Returns true if the configuration properties must be published along with the service. Any additional service properties specified directly are merged with these.
* *name*: The name for this configuration dependency. When you give a name a dependency, it won't be evaluated immediately, but after the component's init method has been called, 
and from the init method, you can then return a map in order to dynamically configure the 
configuration dependency (the map has to contain a "pid" and/or "propagate" flag, prefixed 
with the dependency name). Then the dependency will be evaluated after the component init 
method, and will be injected before the start method. 

Usage Examples

In the following example, the "Printer" component depends on a configuration whose PID name is "org.apache.felix.sample.Printer". This service will initialize its ip/port number from the provided configuration:

    :::java
    package org.apache.felix.sample;
    
    @Component
    public class Printer {
        @ConfigurationDependency
        void updated(Dictionary config) {
            // load printer ip/port from the provided dictionary.
        }
    }

This other example shows how to specify a configuration dependency, as well as meta data used to customize the 
WebConsole GUI. Using these meta data, you can specify for example the default value for your 
configurations data, some descriptions, the cardinality of configuration values, etc ...
(we use here standard bnd metatype annotations, [see bnd metatype documentation here](http://www.aqute.biz/Bnd/MetaType).

 First, we define the configuration metadata, using standard bndtools metatatype annotations:

     :::java
     package sample;
     import aQute.bnd.annotation.metatype.Meta.AD;
     import aQute.bnd.annotation.metatype.Meta.OCD;

     @OCD(description = "Declare here the Printer Configuration.")
     public interface PrinterConfiguration {
         @AD(description = "Enter the printer ip address")
         String ipAddress();

         @AD(description = "Enter the printer address port number.")
         int portNumber();
     }
     
 Next, we define our Printer service which instantiates the PrinterConfiguration using the *Configurable" bndlib helper:

     :::java
     package sample;
     import aQute.bnd.annotation.metatype.*;

     @Component
     public class Printer {
         @ConfigurationDependency(pidClass = PrinterConfiguration.class) // Will use pid "sample.PrinterConfiguration"
         void updated(Dictionary props) {
             // load configuration from the provided dictionary, or throw an exception of any configuration error.
             PrinterConfig cnf = Configurable.createConfigurable(PrinterConfig.class, props);
             String ip = cnf.ipAddress();
             int port = cnf.portNumber();
             ...
         }
     }

Finally, the last example shows how to dynamically configure a configuration dependency pid from the init method.
The following component first depends on a "sample.MyComponent" configuration pid. Then the init method gets from that configuration 
another pid for a second "global" configuration:

    :::java
    package sample;

    /**
      * A Service that dynamically defines an extra dynamic configuration dependency from its init method. 
      */
    @Component
    class MyComponent {
      private Dictionary m_config;
      
      // Inject initial Configuration (injected before any other required dependencies)
      @ConfigurationDependency
      void componentConfiguration(Dictionary config) {
           // you must throw an exception if the configuration is not valid
           m_config = config;
      }
      
      /**
       * All unnamed dependencies are injected: we can now configure our dynamic configuration whose dependency name is "global".
       */
      @Init
      Map init() {
          return new HashMap() {{
              put("global.pid", m_config.get("globalConfig.pid"));
              put("global.propagate", m_config.get("globalConfig.propagate"));
          }};
      } 
 
      // Injected after init, and dynamically configured by the init method.
      @ConfigurationDependency(name="global")
      void globalConfiguration(Dictionary globalConfig) {
           // you must throw an exception if the configuration is not valid
      }
 
      /**
       * All dependencies are injected and our service is now ready to be published.
       */
      @Start
      void start() {
      }
  }
