Title: Dependency Manager - Factory Configuration Adapter Service

A factory configuration adapter service creates an adapter for each matching configuration in Configuration Admin. For each new factory configuration matching the factoryPid, an adapter will be created based on the adapter implementation class. The adapter will be registered with the specified interface and with the specified adapter service properties. Depending on the propagate parameter, every public factory configuration properties (which don't start with ".") will be propagated along with the adapter service properties. It will also inherit all dependencies.

### Usage Examples

    :::java
    manager.createFactoryConfigurationAdapterService("MyFactoryPid", "update", true)
           .setInterface(MyService.class.getName(), new Hashtable() {{ put("foo", "bar"); }})
           .setImplementation(MyServiceImpl.class);         

    class MyServiceImpl implements MyService {
        void update(Dictionary cnf) {
           String ip = (String) cnf.get("address");
           int port = Integer.valueOf(cnf.get("port");
        }
        ...
    }

You an also use "`configuration types`" ([see configuration dependency documentation)](dependency-configuration.html)
This is the same example as above, using a "MyConfig" configuration type:

    :::java
    manager.createFactoryConfigurationAdapterService("MyFactoryPid", "update", true, MyConfig.class)
           .setInterface(MyService.class.getName(), new Hashtable() {{ put("foo", "bar"); }})
           .setImplementation(MyServiceImpl.class);         

    public interface MyConfig {
        String getAddress();
        int getPort();
    }

    class MyServiceImpl implements MyService {
        void update(Dictionary cnf) {
           String ip = cnf.getAddress();
           int port = cnf.getPort();
        }
        ...
    }

## @FactoryConfigurationAdapterService

Annotates a class that acts as a Factory Configuration Adapter Service. 
Like with @ConfigurationDependency, you can optionally specify a configuration type and (optioanlly) use bnd metatype annotations
in order to specify configuration meta data (heading/descriptions/default values, etc ...)

### Annotation attributes:

----
**`configType`**    
*Required*: False    
*Default*: --
The interface to use as the configuration type, which will be injected instead of the actual configuration dictionary.

----
**`provides`**    
*Required*: False    
*Default*: all directly implemented interfaces.
The interface(s) to use when registering adapters. By default, directly implemented interfaces will be registered in the OSGi registry. 

----
**`properties`**    
*Required*: False    
*Default*: --

Adapter Service properties. Notice that public factory configuration is also 
registered in service properties, (only if propagate is true). 
Public factory configuration properties are those which don't starts with a 
dot (".").

----
**`factoryPid`**    
*Required*: False    
*Default*: The class name, including the package.

Returns the factory pid whose configurations will instantiate the 
annotated service class. 
(By default, the pid is the service class name). 

----
**`factoryClass`**    
*Required*: False    
*Default*: The class name, including the package.

Returns the factory pid from a class name. The full class name will be used as the 
configuration PID. You can use this method when you use an interface annoted with 
standard bndtols metatype annotations. (see http://bnd.bndtools.org/chapters/210-metatype.html).

----
**`updated`**    
*Required*: False    
*Default*: "updated"

The Update method to invoke (defaulting to "updated"), when a factory 
configuration is created or updated 

----
**`propagate`**    
*Required*: False    
*Default*: false

Returns true if the configuration properties must be published 
along with the service. Any additional service properties specified directly 
are merged with these. 

----
**`factoryMethod`**    
*Required*: False    
*Default*: --

Sets the static method used to create the adapter instance.

### Usage Examples

Here, a "DictionaryService" service instance is instantiated for each existing 
factory configuration instance matching the "sample.DictionaryServiceFactory" factory pid:

    :::java
    @FactoryConfigurationAdapterService(factoryPid="sample.DictionaryServiceFactory")
    public class DictionaryImpl implements DictionaryService
    {
        /**
          * The key of our config admin dictionary language.
          */
        final static String LANG = "lang";
             
        /**
          * The key of our config admin dictionary values.
          */
        final static String WORDS = "words";
             
        /**
          * We store all configured words in a thread-safe data structure, because ConfigAdmin
          * may invoke our updated method at any time.
          */
        private CopyOnWriteArrayList<String> m_words = new CopyOnWriteArrayList<String>();
             
        /**
          * Our Dictionary language.
          */
        private String m_lang;
         
        protected void updated(Dictionary<String, ?> config) {
            m_lang = (String) config.get(LANG);
            m_words.clear();
            String[] words = (String[]) config.get(WORDS);
            for (String word : words) {
                m_words.add(word);
            }
         }   
             // ...
    }

Here is the same example as above, but using a configuration type as well as meta types (the DM annotations metatype attributes are deprecated and 
it's better to use standard bnd metatype annotations):

First, we declare our factory configuration metadata using standard bndtools metatype annotations (see http://bnd.bndtools.org/chapters/210-metatype.html):

    :::java
    package sample;
    import java.util.List;
    import aQute.bnd.annotation.metatype.Meta.AD;
    import aQute.bnd.annotation.metatype.Meta.OCD;

    @OCD(factory = true, description = "Declare here some Dictionary instances.")
    public interface DictionaryConfiguration {
       @AD(description = "Describes the dictionary language.", deflt = "en")
       String lang();

       @AD(description = "Declare here the list of words supported by this dictionary.")
       List words();
    }
     
And here is the DictionaryService:

    :::java
    import java.util.List;
    import aQute.bnd.annotation.metatype.Configurable;

    @FactoryConfigurationAdapterService(configType=DictionaryConfiguration.class)  
    public class DictionaryImpl implements DictionaryService {
        protected void updated(DictionaryConfiguration config) {   
            m_lang = config.lang();
            m_words.clear();
            for (String word : conf.words()) {
                m_words.add(word);
            }
        }
        ...
    }

