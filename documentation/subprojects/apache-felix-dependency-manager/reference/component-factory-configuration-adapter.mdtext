Title: Dependency Manager - Factory Configuration Adapter Service

A factory configuration adapter service creates an adapter for each matching configuration in Configuration Admin. For each new factory configuration matching the factoryPid, an adapter will be created based on the adapter implementation class. The adapter will be registered with the specified interface and with the specified adapter service properties. Depending on the propagate parameter, every public factory configuration properties (which don't start with ".") will be propagated along with the adapter service properties. It will also inherit all dependencies.

Usage Example:

	manager.createFactoryConfigurationAdapterService("MyFactoryPid", "update", true)
		.setInterface(AdapterService.class.getName(), new Hashtable() {{ put("foo", "bar"); }})
		.setImplementation(AdapterServiceImpl.class);         

## @FactoryConfigurationAdapterService

Annotates a class that acts as a Factory Configuration Adapter Service. 
For each new Config Admin factory configuration matching the specified 
factoryPid, an instance of this service will be created. The adapter will be 
registered with the specified interface, and with the specified adapter 
service properties. Depending on the propagate parameter, every public 
factory configuration properties (which don't start with ".") will be 
propagated along with the adapter service properties.

Like in @ConfigurationDependency, you can optionally specify the meta types of 
your configurations for Web Console GUI customization (configuration 
heading/descriptions/default values/etc ...). 

### Annotation attributes:

----
**`provides`**    
*Required*: False    
*Default*: all directly implemented interfaces.
The interface(s) to use when registering adapters. By default, directly implemented interfaces will be registered in the OSGi registry. 

----
**`properties`**    
*Required*: False    
*Default*: --

Adapter Service properties. Notice that public factory configuration is also 
registered in service properties, (only if propagate is true). 
Public factory configuration properties are those which don't starts with a 
dot (".").

----
**`factoryPid`**    
*Required*: False    
*Default*: The class name, including the package.

Returns the factory pid whose configurations will instantiate the 
annotated service class. 
(By default, the pid is the service class name). 

----
**`factoryClass`**    
*Required*: False    
*Default*: The class name, including the package.

Returns the factory pid from a class name. The full class name will be used as the 
configuration PID. You can use this method when you use an interface annoted with 
standard bndtols metatype annotations. (see http://www.aqute.biz/Bnd/MetaType).

----
**`updated`**    
*Required*: False    
*Default*: "updated"

The Update method to invoke (defaulting to "updated"), when a factory 
configuration is created or updated 

----
**`propagate`**    
*Required*: False    
*Default*: false

Returns true if the configuration properties must be published 
along with the service. Any additional service properties specified directly 
are merged with these. 

----
**`factoryMethod`**    
*Required*: False    
*Default*: --

Sets the static method used to create the adapter instance.

### Usage Examples

Here, a "Dictionary" service instance is instantiated for each existing 
factory configuration instances matching the "DictionaryServiceFactory" 
factory pid:

    :::java
    @FactoryConfigurationAdapterService(factoryPid="DictionaryServiceFactory", updated="updated")
    public class DictionaryImpl implements DictionaryService
    {
        /**
          * The key of our config admin dictionary language.
          */
        final static String LANG = "lang";
             
        /**
          * The key of our config admin dictionary values.
          */
        final static String WORDS = "words";
             
        /**
          * We store all configured words in a thread-safe data structure, because ConfigAdmin
          * may invoke our updated method at any time.
          */
        private CopyOnWriteArrayList<String> m_words = new CopyOnWriteArrayList<String>();
             
        /**
          * Our Dictionary language.
          */
        private String m_lang;
         
        protected void updated(Dictionary<String, ?> config) {
            m_lang = (String) config.get(LANG);
            m_words.clear();
            String[] words = (String[]) config.get(WORDS);
            for (String word : words) {
                m_words.add(word);
            }
         }   
             // ...
    }

Here is the same example as above, but using meta types (the DM annotations metatype attributes are deprecated and 
it's better to use standard bnd metatype annotations, the following example are using bnd metatypes):

First, we declare our factory configuration metadata using standard bndtools metatype annotations (see http://www.aqute.biz/Bnd/MetaType):

    :::java
    package sample;
    import java.util.List;
    import aQute.bnd.annotation.metatype.Meta.AD;
    import aQute.bnd.annotation.metatype.Meta.OCD;

    @OCD(factory = true, description = "Declare here some Dictionary instances.")
    public interface DictionaryConfiguration {
       @AD(description = "Describes the dictionary language.", deflt = "en")
       String lang();

       @AD(description = "Declare here the list of words supported by this dictionary.")
       List words();
    }
     
And here is the Dictionary service, and we instantiate our DictionaryConfiguration interface using the bndlib *Configurable* helper class.

    :::java
    import java.util.List;
    import aQute.bnd.annotation.metatype.Configurable;

    @FactoryConfigurationAdapterService(factoryPidClass=DictionaryConfiguration.class)  
    public class DictionaryImpl implements DictionaryService {
        protected void updated(Dictionary<String, ?> props) {
            // load configuration from the provided dictionary, or throw an exception of any configuration error.
            DictionaryConfiguration cnf = Configurable.createConfigurable(DictionaryConfiguration.class, props);
     
            m_lang = config.lang();
            m_words.clear();
            for (String word : conf.words()) {
                m_words.add(word);
            }
        }
        ...
    }

