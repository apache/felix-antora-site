Title: Dependency Manager - Resource Adapter

Resource adapters work just like adapters, but instead of working with services, they work with resources. Resources, represented as a URL, are an abstraction introduced to provide a generic way of dealing with "blobs" and can be resources inside a bundle, filesystem or some kind of data store.

A resource adapter will be applied to any resource that matches the specified filter condition. For each matching resource an adapter will be created based on the adapter implementation class. The adapter will be registered with the specified interface and existing properties from the original resource plus any extra properties you supply here. It will also inherit all dependencies, and if you declare the original service as a member it will be injected.

## Usage Example using API:

Here, the "VideoPlayer" service provides a video service on top of any movie 
resources, with service properties "host"/"port"/"protocol"/"path" extracted 
from the resource URL:

    :::java
    public class VideoPlayerImpl implements VideoPlayer {
        // Injected by reflection
        volatile URL resource;
             
        void play() {} // play video referenced by this.resource     
        void stop() {} // stop playing the video
        void transcode() {} // ...
    }

    public class Activator extends DependencyManagerActivator {
        public void init(BundleContext ctx, DependencyManager dm) throws Exception {
            Component c = manager.createResourceComponent()
                .setResourceFilter("(&(path=/videos/*.mkv)(host=localhost))")
                .setPropate(true)
                .setInterface(AdapterService.class.getName(), new Hashtable() {{ put("foo", "bar"); }})
                .setImplementation(AdapterServiceImpl.class);
            dm.add(c);
        }
    }

Notice that resource adapters are only supported with the DM API, not using annotations or using DM lambda.
