Title: Dependency Manager - Components

Components are declared by the dependency manager and can be implemented by POJOs that contain no references to the OSGi framework whatsoever. Components are the main building blocks of your OSGi application. They have a life cycle, can register themselves as services and have zero or more dependencies.

You can either use the Java API or the Java Annotations and this reference section describes both.

## Types of Components

There are different types of Dependency Manager components:

* [*Component*](component-singleton.html): Components are the main building blocks for OSGi applications. They can publish themselves as a service, and/or they can have dependencies. These dependencies will influence their life cycle as component will only be activated when all required dependencies are available.
* [*Aspect Service*](component-aspect.html): A service that provides a non-functional aspect on top of an existing service. In aspect oriented programming, an aspect, or interceptor can sit between a client and another target service used by the client. An Aspect Service first tracks a target service and is created once the target service is detected. Then the Aspect Service is provided, but with a higher  ranking, and the client is transparently updated with the aspect. Aspects can be chained and may apply to the same target service (and in this case, the ranking of the Aspect service is used to chain aspects in  the proper order).
* [*Adapter Service*](component-adapter.html): A Service that adapts another existing service into a new one. Like with aspects, sometimes you want to create adapters for certain services, which add certain behavior that results in the publication of (in this case) a different service. Adapters can dynamically be added and removed and allow you to keep your basic services implementations clean and simple, adding extra features on top of them in a modular way.
* [*Bundle Adapter Service*](component-bundle-adapter.html): creates an OSGi service a service on top of a given bundle.
* [*Resource Adapter Service*](component-resource-adapter.html): creates an OSGi service on top of a specific Resource.
* [*Factory Configuration Adapter Service*](component-factory-configuration-adapter.html): creates an OSGi service from ConfigAdmin, using a factoryPid, and a ManagedServiceFactory.

## Life cycle

The dependency manager, as part of a bundle, shares the generic bundle life cycle explained in the OSGi specification. The life cycle of the dependency manager itself, and the components it manages, can be located inside the *active* state of the hosting bundle.

Each component you define gets its own life cycle, which is explained in the state diagram below.

<img src="./diagrams/statediagram.png" alt="State diagram" style="width: 430px"/>

A component is associated with an instance. This instance can either be specified directly, or you can specify its class. If you do the latter, the actual instance will be created lazily. 

Changes in the state of the component will trigger the following life cycle methods:

* `init`, 
* `start`, 
* `stop` and 
* `destroy`.

The dependency manager will look for methods with these names and one of the following signatures in this order:

* `(Component)`,
* `()`.

If you don't specify anything, the methods with these names will be invoked on the instance. By using `setCallbacks()` you can however change this behavior: You can change the names of the methods to look for. Any methods that are set to ` null ` will not be invoked at all. Another thing you can do is to specify a different instance to invoke these methods on. If you do that, you will usually want to use the first signature, which gives you a reference to the ` Component ` whose life cycle method was invoked.

Here is a descrition of the component states:

* *Inactive state*: The Component is defined, but not enabled (not yet added to a
DependencyManager object, or the bundle has been stopped). 
* *Waiting for required* state: The Component is enabled (has been added to a
DependencyManager object) and the required dependencies declared in the Activator are 
tracked. The component remains in the current state until all required dependencies are
available.
* *Instantiated and waiting for required* state: All required dependencies declared
in the Activator are available. The Component has been instantiated, has been injected 
with all required dependencies, including optional dependencies on class fields (autoconfig).
and has been invoked in the *init* callback. Now, if some extra required dependencies have
been dynamically added in the *init* callback, then the component remains in the
current state until all extra required dependencies become available.
* *Tracking optional*: All Required dependencies are available (including the ones
that have been dynamically declared from the init component callback). The component has 
been invoked in the *start* callback and the optional dependencies (with callbacks) are 
then tracked.


## What happens during component instantiation ?

1. The service is instantiated.
2. The following special objects are injected through reflection on class fields, if 
they exist (but you can deactivate this behavior from the API):
  * BundleContext
  * ServiceRegistration
  * DependencyManager
  * Component
3. *autoconfig* dependencies are injected through reflection on class fields, if they exist. If an *autoconfig*
optional dependency is unavailable, a NullObject is then injected.
4. Required dependency callbacks defined from the Activator are called.
5. The component *init* method is called, and from that method you can then dynamically add 
more dependencies by using the Component parameter passed to the init method, or using 
a class field of *Component* type (which in this case has been injected during step 2).
6. When all required dependencies (including dependencies dynamically added from the *init*
method) are available, they are injected (using callbacks, or autoconfig).
7. The component *start* callback is invoked.
8. Optional dependencies (with callbacks) are then tracked.
9. The component service(s) is then registered in the OSGi service registry

When using Annotations, there are some specific behaviors:

* The *@init* method may return a Map that contains filters in order to 
dynamically configure dependencies annotated with a *name* attribute, and the dependencies will
then be injected after the *@init* method (exactly if you would have added the dependencies from the init method using the API).
* The *@start* method may return a Map in order to dynamically add more service properties (if the component provides some services).
* The component can be dynamically stopped or restarted using a special *@LifecycleController* annotation.

## Interfaces and properties

Components in the context of the dependency manager can be published as OSGi services under one or more interface names, plus optionally a set of properties. This is no different than a normal OSGi service. It's important to mention that you don't have to register a service. If you don't, you basically created a component that can do work and have dependencies and a managed life cycle.

## Composition

When implementing more complex components, you often find yourself using more than one instance. However, several of these instances might want to have dependencies injected. In such cases you need to tell the dependency manager which instances to consider. This has to be a fixed set of instances however.

## Factories

Out of the box, there already is support for lazy instantiation, meaning that the dependency manager can create component instances for you when their required dependencies are resolved. However, sometimes creating a single instance using a default constructor is not enough. In those cases, you can tell the dependency manager to delegate the creation process to a factory.
