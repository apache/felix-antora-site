=  Apache Felix Manifest Generator (mangen)

== `mangen` - http://www.osgi.org[OSGi] Bundle Manifest generator

== Introduction

[cols=4*]
|===
| The http://www.osgi.org[OSGi] model provides a very powerful and flexible framework for developing Java applications in a modular fashion with a high degree of control over classloading inter-dependencies between modules.
Projects such as [Oscar
| http://oscar.objectweb.org/] and [Felix
| http://incubator.apache.org/felix/] have recognised this power and implemented open source implementations of the framework.
Adding to this is a growing availability of open source application bundles such as those offered via the [Oscar Bundle Repository
| http://oscar-osgi.sourceforge.net/] (aka OBR).
|===

As an active developer of OSGi based application, http://www.ascert.com/[Ascert's] technical staff  grappled with the cumbersome task of manually creating OSGi Bundle Manifests.
This task is never particularly interesting and only gets bigger and nastier as applications grow in size and the number of bundles present.
To alleviate this chore the `mangen` tool has been created, with the following goals:

* Provide automatic scanning of an OSGi bundle JAR to detect references to external classes which require imports and possible export packages
* Support scanning of multiple bundle JARs in a single pass, including any JAR files within a specified directory tree
* Detect the majority of common import and export cases and provide manual override mechanisms to include cases that are not detected
* Provide a simple, extensible, rule based mechansim to allow the required imports and possible exports sets to be refined e.g.
removing un-needed packages, automatic resolving to packages in other JARs etc.
* Provide a simple, extensible, reporting mechanism of actions taken
* Automatic updating of each bundle JAR's Manifest, including a means to easily switch between either OSGi R3 or R4 compatible Manifest headers

If you're not a Java developer, or you're not sure what OSGi is yet, then this tool is probably not for you!

=== Licensing

The `mangen` utility was originally created as a copyrighted &copy;
work of Ascert LLC, and released as _OSI Certified Open Source Software_ for use under the under the terms of the http://www.opensource.org/licenses/cpl1.0.php[Common Public License]

[cols=2*]
|===
| To promote wider use and enhancement, Ascert submitted version 1.0.1 of `mangen` to the http://incubator.apache.org/felix/[Apache Felix] project, where it will be actively developed and maintained by Felix project team.
Availability is now under an [Apache 2.0 style license
| http://www.apache.org/licenses/LICENSE-2.0]
|===

Included third-party libraries and contributions are copyrighted &copy;
works of their respective owners and are provided under the terms of their specified licenses.

== Using `mangen`

=== Basic operation

Using mangen is very simple.
Unpack the distribution file to an installation directory, change to this directory and type the following command:

     java -jar lib/mangen.jar <file-list>

_Note: on Windows platforms you will need to use a '' in place of the '/' file  separator_

Where:

* *+++<file-list>+++* - is either a list of bundle JARs to be processed or a list of directories, or a mix of both.
Each directory will be scanned and all JAR files in the directory, or any sub-directories will be included in the bundle JARs processed.+++</file-list>+++

The basic behaviour of `mangen` is to process the set of bundle JARs supplied and scan the classes within each JAR to build up a set of the possible exports and required imports for each JAR.
Where inner jars are defined using the OSGi `Bundle-ClassPath` header the classes in these will also be scanned and the possible exports and required imports will be included in the sets generated for their enclosing JAR.

Two phases of process happen after JAR scanning has completed:

* Rule execution - typically rules will process the sets of imports and exports determined by `mangen` for each JAR, refining them according to the rule types being executed and the specific rule options
* Report production - typically generating narrative reports on the bundles processed and the rules executed.

[cols=2*]
|===
| Use of the word 'typically' is significant in the above descriptions.
A basic set of xref:#_rules[rules] and xref:#_reports[reports] are included with `mangen` to perform various useful tasks.
This set is infinitely extensible, however, and `mangen` places no restriction on the types of tasks that rules and reports can perform.
|===

The exact rules and reports to be run are entirely controlled by user configurable properties as described below.
If no properties are supplied `mangen` will simply run, process the specified JAR files and exit.

=== Configuring `mangen` with Properties

Properties to control `mangen` behaviour can either be supplied on the command line using the normal `-D` syntax or, for most cases in a `mangen.properties` file.
If the same property name is specified in both then the `-D` command line property value will take precedence of the property file value.

For added flexibility a simple variable expansion syntax is provided to allow the value of one Property value to be used within another property.
Every property value will be scanned for `$\{property-name}` markers.
Where these are found the marker will be replaced with the value of the associated `property-name`.

_Example:_

     mangen.osgi.level=3
     ...
     mangen.rulesets=mangen-rule-R${mangen.osgi.level}-

==== mangen.properties

The `mangen.properties` Property is used to instruct mangen where to find it's properties file.
By default, `mangen` will look for a file named `mangen.properties` in the same directory in which `mangen.jar` was installed (i.e.
`lib/mangen.properties`).
By including a `-Dmangen.properties` setting on the command line a different properties file can be specified.

_Example:_

     java -jar lib/mangen.jar -Dmangen.properties=my_mangen.properties my_app.jar

==== mangen.osgi.level

There are two places in which the `mangen.osgi.level` Property is used:

* internally within `mangen` to determine the correct format of Manifest headers to be processed and generated.
* as a means to guide which rulesets are executed, using the xref:#_configuring_mangen_with_properties[variable-expansion syntax]

At present, this Property should be set to a value of '3' or '4' (the default if not specified will be '3');

==== mangen.rulesets

Rules are the engine room of `mangen`, providing the basic means for refining the `mangen` detected import and export package sets e.g.
removing un-needed or unused exports, supplying package version information, including undetectable package cases such as dynamic classloading.

Rulesets provide a simple means of organising the rules to be executed into groups of rule sets.
The rulesets are specified as a list of comma-separated values, each value specifying the ruleset name prefix.
The following example shows a ruleset definition for 2 rules:

     mangen.rulesets=mangen-rule-first- , mangen-rule-final-
     ...
     mangen-rule-first-0=...
     mangen-rule-first-1=...
     mangen-rule-first-2=...
     ...
     mangen-rule-final-0=...
     mangen-rule-final-1=...

As shown in the example, `mangen` will take each ruleset name and look for sequentially numbered properties, starting from 0 and finishing when no property name is found.
Each rule found will be executed to completion against the processed set of bundle JARs before the next rule property is processed.

Rulesets can be combined with xref:#_configuring_mangen_with_properties[variable-expansion] to provide OSGi version dependent rules as shown the following example.

     mangen.osgi.level=3
     mangen.rulesets=mangen-rule-R${mangen.osgi.level}-
     ...
     mangen-rule-R3-0=...
     ...
     mangen-rule-R4-0=...

Rules themselves are simply specified as a rule type followed by a space separate list of rule specific options e.g.

     mangen.R4.syspackages=java\\..*
     ...
     mangen-rule-basic-0=Ignore imports(${mangen.R4.syspackages})
     mangen-rule-basic-1=DontImportOwnExports

See the xref:#_rules[Rules] section for full details of the currently support rule types.

==== mangen-report

Reports in `mangen` work in a similar fashion to rules but without the ruleset concept.
The set of sequentially numbered `mangen-report-` properties will be scanned to determine which reports should be run e.g.

     mangen-report-0=RuleReport .*
     mangen-report-1=BundleReport .*

See the xref:#_reports[Reports] section for full details of the currently support report types.

==== mangen.failonerror

If set `on` will cause `mangen` to exit with a `System.exit()` error status of 3 if any errors occured.
Typical usage is to allow an external build tool, such as Ant, detect that there were errors.
Additionally, any error messages will also be sent to `stderr` as well as `stdout` if this property is set.

Default is `on`.

==== mangen.failonwarning

If set `on` will cause `mangen` to exit with a `System.exit()` error status of 5 if any warnings occured.
Typical usage is to allow an external build tool, such as Ant, detect that there were warnings.
Additionally, any warning messages will also be sent to `stderr` as well as `stdout` if this property is set.

Default is `off`.

=== Rules

The Rule concept in `mangen` was adopted to avoid hard-coding the types of post-processing steps that a user would be able to perform on the `mangen` generated set of package imports and exports.
The rule syntax is as follows:

     <rule-type> <rule-options>

Where:

* *+++<rule-type>+++* - must be the name of a valid existing rule type, details of which can be found in this section.+++</rule-type>+++
* *+++<rule-options>+++* - will be a list of one or more of the standard options and/or rule specific options.
The standard options are as follows: ** `imports()` - a comma seperated list of package patterns, using the JDK regex format.
These will be matched against a bundle's own import packages during rule processing, the specific handling undertaken for each match being dependent on the *+++<rule-type>+++*.
*Note: each pattern must be separated from the next by a comma (,) and the list must not contain any space characters.* ** `exports()` - a comma seperated list of package patterns, using the JDK regex format.
These will be matched against a bundle's own export packages during rule processing, the specific handling undertaken for each match being dependent on the *+++<rule-type>+++*.
** `sys-packages()` - a comma seperated list of standard 'system package' patterns, using the JDK regex format.
The specific handling undertaken for each match being dependent on the *+++<rule-type>+++*+++</rule-type>++++++</rule-type>++++++</rule-type>++++++</rule-options>+++

Rules will can have either "global" scope, in which case every bundle JAR processed will have the rule appplied, or "local" scope meaning that they will only apply to a single bundle JAR.
Global rules will be included in the `mangen.properties` file.
Local rules are placed within the Manifest for the appropriate bundle in a special `mangen` attributes section e.g.

....
    Bundle-Name: Help Component
    Bundle-ClassPath: .,help4.jar,oracle_ice.jar,ohj-jewt.jar
    Metadata-Location: metadata.xml

    Name: com/ascert/openosgi/mangen
    mangen-rule-0: Ignore imports(com\.adobe\.acrobat.*,webeq\..*,javax\.help,javax\.media)
....

Details are included below showing whether a *+++<rule-type>+++* can be used in a global or a local context+++</rule-type>+++

==== AttributeStamp

[cols=2*]
|===
| _Usable globally_
| `yes`

| _Usable locally_
| `yes`

| _Standard options_
| `imports`, `exports`

| _Rule specific options_
|
|===

When processing a bundle JAR `mangen` can only detect the name of a required import package or a possible export package.
Within an OSGi environment it's possible to also include qualifying information on a package name, such as versioning information.
The AttributeStamp rule allows this information to be "stamped" over a detected package name.

The rule may be supplied locally, in which case it will only apply to instances of a package name match with a specific bundle JAR, or globally in which case it will be applied to all instances of a package name match across all JARs.

The `imports` or `exports` options allow stamping of attributes to either imported or exported packages respectively.
The rule will perform a regex package name match against each entry in the list and if the name matches, will augment the matched package name with any additional attributes suppled.
The following shows an example of this.

_Example:_

     mangen-rule-1=AttributeStamp imports(org\\.osgi\\.framework;version="1.2.0")

If the rule finds a package name pattern match and the package already has additional attributes an error will be thrown if the stamped attributes do not match the existing attributes.
This could be the case as a result of either a previous AttributeStamp or Merge rule.

==== DontImportOwnExports

[cols=2*]
|===
| _Usable globally_
| `yes`

| _Usable locally_
| `yes`

| _Standard options_
|

| _Rule specific options_
|
|===

In many application cases it's not necessary for a bundle JAR to import it' own exports.
This rule may be used locally or globally to remove from a bundle's import list any package which it also exports.

==== Ignore

[cols=2*]
|===
| _Usable globally_
| `yes`

| _Usable locally_
| `yes`

| _Standard options_
| `imports`, `exports`

| _Rule specific options_
|
|===

There are several cases where a `mangen` detected possible export or required import may not actually be desired:

* Standard JDK classes, particularly in an OSGi R3 environment where these packages are resolved without needing import statements
* Packages which `mangen` detects as needing imports but won't actually be used in a running environment.
One example of these is third party JARs which include Ant tasks for use in a development environment but which would probably never be instantiated in a running application.

The Ignore rule will remove matching package entries from either the import or export lists, or both, as specified in the options.

_Example:_

     mangen.R4.syspackages=java\\..*
     mangen-rule-R4-0=Ignore imports(${mangen.R4.syspackages})

==== Merge

[cols=2*]
|===
| _Usable globally_
| `yes`

| _Usable locally_
| `yes`

| _Standard options_
| `imports`, `exports`

| _Rule specific options_
| `existing`, `fixed`
|===

In some cases the simplest way to use `mangen` will be to provide a list of known imports and exports and then have `mangen` "merge" any remaining required imports and possible exports into these lists as needed.
The Merge rule provides two mechanisms in which these known imports and exports can be supplied:

* Using `existing` Manifest entries - in which case `mangen` will take any current Import-Package and Export-Package headers and merge them into the detected import and export package sets
* By specifying a set of `fixed` Manifest entries - allowing a limited set of pre-determined entries to be listed in the special `mangen` attributes of the Manifest which will be merged in.

_Example:_

....
    Manifest-Version: 1.0
    Bundle-Name: mybundle
    Export-Package: my.bundle.package

    Name: com/ascert/openosgi/mangen
    Import-Package: some.other.package
....

A `Merge existing` rule using the above example would ensure that `my.bundle.package` appeared in the list of packages to export.
A `Merge fixed` would ensure that `some.other.package` appeared in the list of packages to import.

It's possible to use both `Merge existing` and `Merge fixed` within a given set of application rules although it's more likely that only one of these would be used to meet a given application build strategy.

The imports and exports options allow constraints on the packages to be merged based on regex package name pattern matches.

One other aspect to note with the Merge option is that it also provides an alternative way to "stamp" OSGi attributes on a `mangen` detected pakcage name, since if the package being merged was already in the set of `mangen` detected packages it's entry will be augmented with any additional attributes supplied from the package entry being merged.

==== ProcessBundles

[cols=2*]
|===
| _Usable globally_
| `yes`

| _Usable locally_
| `no`

| _Standard options_
|

| _Rule specific options_
|
|===

By default, `mangen` will not actually process any of the JAR files specified, it will simply create objects to access them.

Being able to skip `mangen` processing of bundle JARs is useful behaviour in a small number of instances, such as the xref:#_obrreport[ObrReport] that will generally be run against existing bundle Manifest headers rather than `mangen` generated sets of imports and exports.

For most cases, however, `mangen` import and export processing will be required and this Rule should be included.

_Example:_

....
    mangen.rulesets=mangen-rule-initial- , mangen-rule-Ant- , mangen-rule-R${mangen.osgi.level}- , mangen-rule- , mangen-rule-final-

    mangen-rule-initial-0=ProcessBundles
    ...
....

==== ResolveImportsToExports

[cols=2*]
|===
| _Usable globally_
| `yes`

| _Usable locally_
| `no`

| _Standard options_
| `sys-packages`

| _Rule specific options_
|
|===

Some OSGi developers use the framework as a basis for creating packaged applications, in fact it is just this usage which Ascert make of OSGi and Oscar and which motivated the creation of =mangen.
In such cases, the simplest and possibly most powerful rule use case is  simply to supply `mangen` with a complete set of application bundles and let it work out the matrix of imports and exports required to resolve every bundle dependency.
This is exactly what the ResolveImportsToExports does.

ResolveImportsToExports can only be used globally and will prune down the set of possible exports and required imports to just those required to satisfy every bundle dependency.
It will generate `+*** WARNING ***+` report lines for the following cases:

* duplicate exports where more than one bundle could be an exporter of the same package which is a necessary import of some other bundle.
In these cases, at present, the first possible exporter found will be picked and all others removed and a warning generated
* missing exports i.e.
packages required by one or more bundles that are never exported.
Erroneous warnings for standard JDK packages can be avoided using the `sys-packages` option.

At present, the known cases where this rule may fail to create a consistent and resolved set of bundle Manifests are:

* cases of dynamic classloading
* certain third party JARs, such as Xerces, which use the awkaward-to-handle OSGi case of `Thread.getContextClassLoader()` to determine the classloader for dynamic classloading.

==== UpdateBundles

[cols=2*]
|===
| _Usable globally_
| `yes`

| _Usable locally_
| `no`

| _Standard options_
|

| _Rule specific options_
| `overwrite`
|===

By default, `mangen` will only report on the generated list of imports and exports for each bundle processed.
The UpdateBundles rule can be used to instruct `mangen` to update each bundle's Manifest wth the set of generated packages.

This rule can only be used globaly.
If the `overwrite` option is specified, the bundle JAR will overwritten with a new bundle JAR containing the new Manifest.
Without this option, the update will create new JARs of the same name as each existing JAR but with a suffix of `.new.jar`.

=== Reports

Reports are really like a simplified case of rules.
At present only a couple of simple reports are included.

All reports at present send their output to `System.out`, which can of course be redirected to a text file if a persistent copy is desired.

==== RuleReport

This report will show any Rule generated output.

==== BundleReport

[cols=2*]
|===
| _Report options_
| `show-differences` `show-local-rules`
|===

This report will create a simple overview of the refined set of a bundle's imports and exports, together with a report of any local rules which have been run for the bundle.
The following options are supported:

* `show-differences` - will show details of _ADDED_ and _REMOVED_ packages by comparing the generate set of import and export packages against the existing Import-Package and Export-Package attributes.
If this option is omitted a simple list of generated imports and exports will be shown
* `show-local-rules` - will show report output from any local rules run for each bundle JAR

==== ObrReport

[cols=2*]
|===
| _Report options_
| `skip-jars`
|===

Produce a report for each bundle JAR that can be used as an OBR descriptor.

The `skip-jars` option can be used to specify a comma separated list of JAR name regex patterns for which OBR descriptors are not required (e.g.
source JARs).

OBR descriptor production is a quite different aspect of `mangen` usage to import/export generation and so a separate example `obr.properties` file has been included to show typical settings for it's usage.
The `-Dmangen.properties` setting can be used to run `mangen` with these settings e.g.

_Example:_

     java -Dmangen.properties=lib\obr.properties -jar lib\mangen.jar e:\obr\repo\

The example `obr.properties` includes a number of features:

* there is no _ProcessBundles_ rule, meaning that `mangen` will not automatically generate imports and exports.
* there is a _Merge existing_  rule meaning `mangen` will use existing Manifest headers in each bundle JAR to generate the ObrReport
* there is an `mangen.obr.ver` property that can be used to control the format of the OBR descriptors produced
* text templates are included that allow the OBR version 1 and version 2 descriptors to be changed without needing to modify the ObrReport code.

Whilst running, the ObrReport will look for a number of specific properties to aid it's processing:

* `mangen.obr.ver` - to determine which format of OBR descriptor to produce
* `mangen.obr.descr.<obr-ver>` - the main text template used to produce the OBR descriptor for each bundle
* `mangen.obr.import.<obr-ver>` - the template used to produce the descriptor text for each import.
* `mangen.obr.export.<obr-ver>` - the template used to produce the descriptor text for each export.
* `mangen.obr.import.ver.<obr-ver>` - the template used to produce a "version" descriptor for an import which has an explicit version specified.
* `mangen.obr.export.ver.<obr-ver>` - the template used to produce a "version" descriptor for an export which has an explicit version specified.

The templates include a simple "tag substitution" mechanism that will expand the following tags:

* `@@hdr:<header-name>@@` - include the attribute value of +++<header-name>+++from the bundle's Manifest.
The `mangen` attributes will be searched first, followed by the Main attributes+++</header-name>+++
* `@@imports@@` - process the list of imports and generate descriptor text based on the `mangen.obr.import.<obr-ver>` template
* `@@exports@@` - process the list of exports and generate descriptor text based on the `mangen.obr.export.<obr-ver>` template
* `@@import-ver@@` - will be expanded using `mangen.obr.import.ver.<obr-ver>` if an explicit version was included for the import package
* `@@export-ver@@` - will be expanded using `mangen.obr.export.ver.<obr-ver>` if an explicit version was included for the export package
* `@@pkg:name@@` - name of the import or export package currently being processed
* `@@pkg:ver@@` - version of the import or export package currently being processed

=== Contents of the distribution file

The current `mangen` distribution includes the following:

* pre-compiled versions of `mangen` and libraries
* full source code and Ant build files
* this documentation in HTML format.
The original documentation is maintained in TWiki format at Ascert's intranet set and a copy of the raw TWiki file is included.

The following third party libraries are also included in the distribution:

* http://incubator.apache.org/felix/[Felix] library JARs - required Felix library JARs, used by `mangen` in Manifest processing, and generation
* http://asm.objectweb.org/[ASM] - the ASM java bytecode parsing toolkit used by the `ASMClassScanner` class scanning implementation.
* http://jakarta.apache.org/bcel/[BCEL] - the BCEL java  bytecode parsing toolkit used by the `BCELScanner` class scanning implementation.

Thanks also go to the following contributors:

* link:{{ refs.mailto-heavy-ungoverned-org.path }}[Richard S. Hall] - both for his assistance in the development and testing of `mangen` and for his contribution of the ASM based class scanning implementation.

== Extending `mangen`

First things first.
You need to be a reasonably proficient Java developer to undertake extending `mangen`.
If you're not, then you should consider a Java programming course or tutorial of some kind.

Extensions to `mangen` can be performed in the following ways:

* creating new or enhanced Rules
* creating new or enhanced Reports
* supporting alternative class scanning implementations
* Modifying the core source code

The idea is that as `mangen` matures most extension cases will be possible via the first two means, with new class scanners and core modifications being the exception.

For detailed information, Javadoc API documentation for `mangen` can be found @@api-index-loc@@.

=== Creating new Rule types

A rule type is in fact just a Java class which implements the `com.ascert.openosgi.Rule` interface.
If no package name is specified, these will be assumed to be in the `com.ascert.openosgi.mangen.rules` package.
Although somewhat less readable, a fully-qualified class name can be supplied for rule types in other packages.

At present, the simplest way to learn about creating new rules is to look at the source code for existing rules to understand how they're put together and what can be done in them.

=== Creating new Report types

Reports are similar to rules.
A Report type is a Java class which implements the `com.ascert.openosgi.Report` interface.
Unqualified report types will be assumed to be in `com.ascert.openosgi.mangen.reports` package, with the option to use fully-qualified class names if desired.

As with rules, the source code for the existing reports is the best place to learn about creating new reports.

=== Alternative class scanners

To parse the class files of an application `mangen` needs a class file bytecode scanning library.
So that alternative scanning tools may be used `mangen` does not make direct usage of any library implementation.
Instead a wrapper class is used which implements the `ClassScanner` interface, and hence insulates `mangen` from the specific details of different bytecode scanning tools.
The `mangen.scanner.class` property can be used to control which scanner implementation class is used.

[cols=2*]
|===
| At present, implementations of the  `ClassScanner` interface have been include for the ObjectWeb http://asm.objectweb.org/[ASM] toolkit and the  [Apache BCEL
| http://jakarta.apache.org/bcel/] toolkit.
|===

== Ongoing Development

=== Change Log

==== Version 1.0.1

* Initial version submitted to Felix project.
* Package names changed and license headers changed to Apache license
* `OsgiPackage` classes changed to use Felix manifest handling classes.
* ASM and BCEL sources removed and maven dependencies created to pull these in from repositories.
* Compiles and builds using normal maven build, but as yet doesn't create a standalone distribution which includes dependent jars and config `.properties` files.
* No analysis work has been performed to determine enhancements and additional rules desirable to integrate with Felix build and take advantage of `mangen` class scanning.

==== 0.1.x Versions

The 0.1.x versions of `mangen` are the original versions developed to work with Oscar.
The versions and documentation can still be downloaded from the http://oscar-osgi.sourceforge.net/mangen/[OBR Sourceforge site].
The change history has been maintained here for completeness.

===== Version 0.1.2

* Inclusion of xref:#_obrreport[ObrReport] for generation of OBR descriptors _[ oscar-osgi-Feature Requests-1221468 ]_
* Removed "default" processing of JARs.
Now an explicit xref:#_processbundles[ProcessBundles] must be included to force JAR processing to take place.
This allows reports, such as the new ObrReport to skip `mangen` import/export processing and just work from existing manifests.
* default `mangen.properties` now explicitly lists each non java.* package rather than using wildcards, proved safer and more reliable when creating OSGi R4 manifests

===== Version 0.1.1

* Support for errors and warnings to cause non-zero exit status to be returned
* Fix for occasional failures to update bundle JARs _link:{{ refs.-oscar-osgi-bugs-1218334.path }}[oscar-osgi-Bugs-1218334]_

===== Version 0.1.0

* First version
* Support for current OSGi Release 3 (R3) manifest headers, and basic support for proposed upcoming R4 headers
* Processing of JARs and directories containing JARs and parsing of contained classes using a subset of BCEL.
* Simple but extensible rule based engine for import and export set manipulation.
* Simple but extensible reporting engine
* Updating of process bundle JARs via an UpdateBundles rule
* Pluggable interface to allow alternative class byte code scanners to be used

=== Possible Enhancements

As with any piece of software, there are always more things you'd like to do than time available in which to work on them.
This library is no exception.

In it's present form it `mangen` is simple, reasonably fast, and usable.
Ideas on some of the more significant areas where it could be enhanced or improved are described in the sections below.

Most `mangen` enhancement ideas have now been created as issues in the https://issues.apache.org/jira/secure/IssueNavigator.jspa?component=12310910&sorter/field=priority&mode=hide&reset=true&pid=12310100&sorter/order=ASC[Apache JIRA list].

Those which are more speculative have been left below.

==== Online usage within an OSGi environment

[cols=3*]
|===
| Extending the concept of Manifest-less usage (no link) comes an interesting possibility that a specific OSGi platform such as [Oscar
| http://oscar.objectweb.org/] could be extended to load any JAR and automatically 'fix-up' a usable Manifest.
This would require internal access/knowledge of the specific platform's implementation since the existing standard OSGi API would not supply sufficient details and access to the set of loaded bundle JARs.
Additionally, it would probably need to be a "multi-step" process since until a largely complete set of bundle JARs were loaded it may not be possible to resolve all imports and exports.
This perhaps implies some form of platform extension to allow a set of JARs to be passed to some form of "pre-load" mechanism capable of resolving their imports and exports within the JAR set, and possibly from existing loaded bundle JARs or even an external [OBR
| http://oscar-osgi.sourceforge.net/].
|===

== Acknowledgements

Ascert is pleased to acknowledge the following projects, organisations and individuals whose tools have been used in the creation of this software:

* http://asm.objectweb.org/[ASM] - ObjectWeb's bytecode scanning and manipulation toolkit.
* http://jakarta.apache.org/bcel/[BCEL] - Apache's bytecode scanning and manipulation toolkit.
* http://www.jedit.org[jEdit] - home of the powerful and flexible jEdit    editor
* http://ant.apache.org[Ant] - home of the Apache Ant build tool
* {blank}
+
[cols=2*]
|===
| http://www.bluemarsh.com/[Blue Marsh Softworks] - authors of the excellent [JSwat
| http://www.bluemarsh.com/java/jswat/index.html] Java debugger.
|===

* {blank}
+
[cols=3*]
|===
| http://subversion.tigris.org/[Subversion] - home of the Subversion (aka SVN) version control system, and [Regnis
| http://www.regnis.de/] and [TortoiseSVN
| http://tortoisesvn.tigris.org/], both of which are excellent SVN GUI clients
|===

* http://java.sun.com[Sun Java] - home of all things Java and a place we love.
